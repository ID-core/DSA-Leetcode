// 46. Permutations
// https://leetcode.com/problems/permutations/?envType=problem-list-v2&envId=backtracking

class Solution {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        printpermutation(nums, new ArrayList<>(), result);
        return result;
    }

    public static void printpermutation(int[] nums,
            List<Integer> permute,
            List<List<Integer>> result) {

        if (nums.length == 0) {
            result.add(new ArrayList<>(permute));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            int current = nums[i];

            // create new array without current
            int[] newnum = new int[nums.length - 1];
            for (int j = 0, k = 0; j < nums.length; j++) {
                if (j != i) {
                    newnum[k++] = nums[j];
                }
            }

            permute.add(current); //adding current value in this list like [] -> [current]
            printpermutation(newnum, permute, result);
            permute.remove(permute.size() - 1); //backtracking- removing the last added choice (or undo)
        }
    }
}



// 51. N-Queens
// https://leetcode.com/problems/n-queens/description/?envType=problem-list-v2&envId=backtracking

class Solution {

    public static boolean issafe(int row, int col, char[][] board) {

        // check column
        for (int i = 0; i < board.length; i++) {
            if (board[i][col] == 'Q') return false;
        }

        // check row
        for (int j = 0; j < board.length; j++) {
            if (board[row][j] == 'Q') return false;
        }

        // upper-left diagonal
        for (int r = row, c = col; r >= 0 && c >= 0; r--, c--) {
            if (board[r][c] == 'Q') return false;
        }

        // upper-right diagonal
        for (int r = row, c = col; r >= 0 && c < board.length; r--, c++) {
            if (board[r][c] == 'Q') return false;
        }

        // bottom-left diagonal
        for (int r = row, c = col; r < board.length && c >= 0; r++, c--) {
            if (board[r][c] == 'Q') return false;
        }

        // bottom-right diagonal
        for (int r = row, c = col; r < board.length && c < board.length; r++, c++) {
            if (board[r][c] == 'Q') return false;
        }

        return true;
    }

    public static void saveboard(char[][] board, List<List<String>> allboard) {
        List<String> newBoard = new ArrayList<>();

        for (int i = 0; i < board.length; i++) {
            String row = "";
            for (int j = 0; j < board.length; j++) {
                row += board[i][j];
            }
            newBoard.add(row);
        }
        allboard.add(newBoard);
    }

    public static void helper(char[][] board, List<List<String>> allboard, int col) {
        if (col == board.length) {
            saveboard(board, allboard);
            return;
        }

        for (int row = 0; row < board.length; row++) {
            if (issafe(row, col, board)) {
                board[row][col] = 'Q';
                helper(board, allboard, col + 1);
                board[row][col] = '.'; // backtrack
            }
        }
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> allboard = new ArrayList<>();
        char[][] board = new char[n][n];

        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }

        helper(board, allboard, 0);
        return allboard;
    }
}



// 37. Sudoku Solver
// https://leetcode.com/problems/sudoku-solver

class Solution {
    public boolean isSafe(char[][] board, int row, int col, int number) {
        char num = (char) (number + '0');

        // Checking row and column
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == num)
                return false;
            if (board[row][i] == num)
                return false;
        }
        //for grid number
        // formula to find the grid number
        int sr = (row / 3) * 3;
        int sc = (col / 3) * 3;

        for (int i = sr; i < sr + 3; i++) {
            for (int j = sc; j < sc + 3; j++) {
                if (board[i][j] == num)
                    return false;
            }
        }

        return true;
    }

    // Backtracking helper
    public boolean helper(char[][] board, int row, int col) {

        // Finished all rows -> solved
        if (row == 9)
            return true;

        int nrow, ncol;
        if (col != 8) {
            nrow = row;
            ncol = col + 1;
        } else {
            nrow = row + 1;
            ncol = 0;
        }

        // If already filled, moving to next cell
        if (board[row][col] != '.') {
            return helper(board, nrow, ncol);
        }

        // Trying digits 1 to 9
        for (int i = 1; i <= 9; i++) {
            if (isSafe(board, row, col, i)) {
                board[row][col] = (char) (i + '0');

                if (helper(board, nrow, ncol)) {
                    return true;
                }
                board[row][col] = '.';
            }
        }

        return false;
    }

    // Main function
    public void solveSudoku(char[][] board) {
        helper(board, 0, 0);
    }
}



// 75. Set Colors
// https://leetcode.com/problems/sort-colors/description/?envType=problem-list-v2&envId=sorting

class Solution {
    public void sortColors(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        for (int i = 0; i <= right;) {
            if (nums[i] == 0) {
                swap(nums, i, left);
                left++;
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else //when nums[i] == 2
            {
                swap(nums, i, right);
                right--;
            }
        }
    }
    private static void swap(int nums[], int i, int j) {
        final int temp;
        temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}


// 15. 3Sum
// https://leetcode.com/problems/3sum/description/?envType=problem-list-v2&envId=sorting

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1 - 1; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) //ignoring duplicates
                continue;
            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;

                    while (left < right && nums[left] == nums[left - 1])
                        left++;
                    while (left < right && nums[right] == nums[right + 1])
                        right--;
                } else if (sum > 0) {
                    right--;
                } else
                    left++;

            }
        }
        return result;
    }
}


// 18. 4Sum
// https://leetcode.com/problems/4sum/description/?envType=problem-list-v2&envId=sorting

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int n = nums.length;

        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1;
                int right = n - 1;

                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                    if (sum == target) {
                        result.add(Arrays.asList(
                                nums[i], nums[j], nums[left], nums[right]
                        ));

                        left++;
                        right--;

                        while (left < right && nums[left] == nums[left - 1]) left++;
                        while (left < right && nums[right] == nums[right + 1]) right--;
                    }
                    else if (sum < target) {
                        left++;
                    }
                    else {
                        right--;
                    }
                }
            }
        }
        return result;
    }
}
