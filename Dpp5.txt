// 242. Valid Anagram
// https://leetcode.com/problems/valid-anagram/description/


class Solution {
    public boolean isAnagram(String s, String t) {
        char a[] = s.toCharArray(); //convert strting s to charater and store them as array in 'a'
        char b[] = t.toCharArray();
        if(a.length != b.length)
        {
            return false;
        }
        Arrays.sort(a);
        Arrays.sort(b);
        return Arrays.equals(a,b);
    }
}



// 49. Group Anagrams
// https://leetcode.com/problems/group-anagrams/description/

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
       HashMap<String, List<String>> hash = new HashMap<>();
    //    Create a HashMap where each key is a sorted word, and each value is a list of strings that are anagrams of each other

    for(String s: strs) // for each string s from array strs
    {
        char arr[]= s.toCharArray();
        Arrays.sort(arr);

        String key = new String(arr); //converting char into string again
        if(!hash.containsKey(key))
        {
            hash.put(key, new ArrayList<>());
        }
        hash.get(key).add(s);
    }
    return new ArrayList<>(hash.values());
    }
}



// 3. Longest Substring Without Repeating Charaters
// https://leetcode.com/problems/longest-substring-without-repeating-characters/

class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int max_len = 0;

        for (int i = 0; i < n; i++) {
            int length = 0;
            boolean[] visited = new boolean[256];
            for (int j = i; j < n; j++) {
                if (visited[s.charAt(j)]) {
                    break;
                }
                visited[s.charAt(j)] = true;
                length++;

            }
            max_len = Math.max(max_len, length);
        }
        return max_len;

    }
}


// 424. Longest Repeating Character Replacement
// https://leetcode.com/problems/longest-repeating-character-replacement/

// This code finds the length of the longest substring where we can make all letters the same by changing at most k characters
// We use a sliding window from left to right, keeping track of the count of each letter in the window
// maxFreq stores the count of the most frequent letter in the current windo
// If the number of letters to change (window length - maxFreq) is more than k,we shrink the window from the left
// We keep updating the maximum valid window length as the answer

class Solution {
    public int characterReplacement(String s, int k) {

        int[] count = new int[26]; // count of A-Z
        int left = 0;
        int maxFreq = 0; // max freq of any char in window
        int result = 0;

        for (int right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);
            count[ch - 'A']++;

            // update the max frequency char in the window
            maxFreq = Math.max(maxFreq, count[ch - 'A']);

            int window = right - left + 1;

            // if we need more than k changes â†’ shrink
            if (window - maxFreq > k) {
                count[s.charAt(left) - 'A']--;
                left++;
                window--;
            }

            result = Math.max(result, window);
        }

        return result;
    }
}
