// 153. Find Minimum in Rotated Sorted Array
// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;

        while (low < high) {
            int mid = low + (high - low) / 2;    //using this formula for mid as it avoids overflow in int

            // If middle element is greater than last element,
            // minimum is in the right half
            if (nums[mid] > nums[high]) {
                low = mid + 1;
            } else {
                // Minimum is in the left half including mid
                high = mid;
            }
        }

        return nums[low]; // or nums[high], both same
    }
}


// 33. Search in Rotated Sorted Array
// https://leetcode.com/problems/search-in-rotated-sorted-array/description/

class Solution {
    public int search(int[] nums, int target) {
       for(int i=0; i <nums.length; i++)
       {
        if (nums[i]== target)
        {
            return i;
        }
       }
       return -1;
    }
}



// 172. Factorial Trailing Zeroes
// https://leetcode.com/problems/factorial-trailing-zeroes/description/

//Trailing zeros depend on the number of complete pairs (2, 5). But because: There are ALWAYS more 2s than 5s, the number of pairs = number of 5s. So we only count 5s, because 2s are never the limiting factor.

class Solution {
    public int trailingZeroes(int n) {
        int count = 0;
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
}



// 57. Insert Interval
// https://leetcode.com/problems/insert-interval/


class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {

        List<int[]> ans = new ArrayList<>();

        for(int [] interval :intervals)
        {
            if(interval[1] < newInterval[0])
            {
                ans.add(interval);
            }
            else if(interval[0] > newInterval[1])
            {
                ans.add(newInterval);
                newInterval = interval;
            }
            else
            {
                 newInterval[0] = Math.min(newInterval[0], interval[0]);
                newInterval[1] = Math.max(newInterval[1], interval[1]);
            }
        }

        ans.add(newInterval);

        return ans.toArray(new int[ans.size()][]);
    }
}



// 56. Merge Interval
// https://leetcode.com/problems/merge-intervals/description/


class Solution {
    public int[][] merge(int[][] intervals) {

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]); //sorting by start time in intervals

        List<int[]> merged = new ArrayList<>();

        int start = intervals[0][0];
        int end = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {
            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (currStart <= end) {
                end = Math.max(end, currEnd);
            } else {
                merged.add(new int[]{start, end});
                start = currStart;
                end = currEnd;
            }
        }

        merged.add(new int[]{start, end});
        return merged.toArray(new int[merged.size()][]);
    }
}
