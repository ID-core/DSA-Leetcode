// 153. Find Minimum in Rotated Sorted Array
// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;

        while (low < high) {
            int mid = low + (high - low) / 2;    //using this formula for mid as it avoids overflow in int

            // If middle element is greater than last element,
            // minimum is in the right half
            if (nums[mid] > nums[high]) {
                low = mid + 1;
            } else {
                // Minimum is in the left half including mid
                high = mid;
            }
        }

        return nums[low]; // or nums[high], both same
    }
}


// 33. Search in Rotated Sorted Array
// https://leetcode.com/problems/search-in-rotated-sorted-array/description/

class Solution {
    public int search(int[] nums, int target) {
       for(int i=0; i <nums.length; i++)
       {
        if (nums[i]== target)
        {
            return i;
        }
       }
       return -1;
    }
}



// 172. Factorial Trailing Zeroes
// https://leetcode.com/problems/factorial-trailing-zeroes/description/

//Trailing zeros depend on the number of complete pairs (2, 5). But because: There are ALWAYS more 2s than 5s, the number of pairs = number of 5s. So we only count 5s, because 2s are never the limiting factor.

class Solution {
    public int trailingZeroes(int n) {
        int count = 0;
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
}