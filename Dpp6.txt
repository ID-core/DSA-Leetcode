// 344. Reverse String
// https://leetcode.com/problems/reverse-string/?envType=problem-list-v2&envId=string

class Solution {
    public void reverseString(char[] s) {
        char temp; int n=s.length;
        for(int i=0;i<n/2;i++)
        {
            temp = s[i];
            s[i] = s[n-i-1];
            s[n-i-1] = temp;
        }
    }
}



// 541. Reverse String II
// https://leetcode.com/problems/reverse-string-ii/description/?envType=problem-list-v2&envId=string

class Solution {
    public String reverseStr(String s, int k) {
        char[] arr = s.toCharArray();
        int n = arr.length;
        char temp;

        // process each 2k block
        for (int i = 0; i < n; i += 2 * k) {
            // calculate the end of the block safely
            int right = Math.min(i + k - 1, n - 1);

            // reverse the block using only i
            for (int j = 0; j < (right - i + 1) / 2; j++) {
                temp = arr[i + j];
                arr[i + j] = arr[right - j];
                arr[right - j] = temp;
            }
        }

        return new String(arr);
    }
}



// 1668. Maximum Repeating Substring
// https://leetcode.com/problems/maximum-repeating-substring/description/?envType=problem-list-v2&envId=string

class Solution {
    public int maxRepeating(String sequence, String word) {
        int k = 0;
        String repeated = word;
        // Keep checking if word repeated k+1 times is a substring
        // Increment k until it is no longer a substring
        while (sequence.contains(repeated)) {
            k++;
            repeated += word; // append word again
        }
        return k;
    }
}



// 3210. Find the Encrypted String
// https://leetcode.com/problems/find-the-encrypted-string/description/?envType=problem-list-v2&envId=string

class Solution {
    public String getEncryptedString(String s, int k) {
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<n;i++)
        {
            int ind = (i+k)%n; //cyclic shifting approach
            sb.append(s.charAt(ind));
        }
        return sb.toString();
    }
}


// 468. Validate IP Address
// https://leetcode.com/problems/validate-ip-address/description/?envType=problem-list-v2&envId=string

class Solution {

    public String validIPAddress(String queryIP) {
        if (queryIP.contains(".")) {
            return isIPv4(queryIP) ? "IPv4" : "Neither";
        } else if (queryIP.contains(":")) {
            return isIPv6(queryIP) ? "IPv6" : "Neither";
        }
        return "Neither";
    }

    private boolean isIPv4(String ip) {
        String[] parts = ip.split("\\.", -1);
        if (parts.length != 4) return false;

        for (String part : parts) {
            if (part.length() == 0 || part.length() > 3) return false;

            // no leading zeros
            if (part.length() > 1 && part.charAt(0) == '0') return false;

            // digits only
            for (char c : part.toCharArray()) {
                if (!Character.isDigit(c)) return false;
            }

            // convert and check range
            int num = Integer.parseInt(part);
            if (num < 0 || num > 255) return false;
        }
        return true;
    }

    private boolean isIPv6(String ip) {
        String[] parts = ip.split(":", -1);
        if (parts.length != 8) return false;

        for (String part : parts) {
            if (part.length() == 0 || part.length() > 4) return false;

            for (char c : part.toCharArray()) {
                if (!Character.isDigit(c) &&
                    !(c >= 'a' && c <= 'f') &&
                    !(c >= 'A' && c <= 'F')) return false;
            }
        }
        return true;
    }
}


// 1807. Evaluate the bracket pairs of a string
// https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/description/?envType=problem-list-v2&envId=string

class Solution {
    public String evaluate(String s, List<List<String>> knowledge) {
        //Making map
        Map<String, String> map = new HashMap<>();

        //putting each value inside it
        for(int i =0; i< knowledge.size(); i++)
        {
            List<String> pair = knowledge.get(i);
            String key = pair.get(0);
            String value = pair.get(1);
            map.put(key,value);
        }

        // Variable for storing anwers
        StringBuilder key = new StringBuilder();
        StringBuilder ans = new StringBuilder();
        boolean readingkey = false;

        for(int i=0; i<s.length(); i++)
        {
            char c= s.charAt(i);
            if(c == '(')
            {
                key.setLength(0); // Clear all content ok key, before starting new one
                readingkey = true;
            }
            else if (c == ')')
            {
                String keytext= key.toString();
                if(map.containsKey(keytext))
                {
                    ans.append(map.get(keytext));
                }
                else
                {ans.append("?");}
                readingkey = false;
            }
            /* We go through the string character by character.
            When we see '(', we set readingkey = true to start reading a key.
            Each character inside the parentheses is added to the key using key.append(c).
            For example, for "(name)", we read 'n', 'a', 'm', 'e' one by one,
            so key becomes "n", then "na", then "nam", and finally "name".
            When we see ')', we set readingkey = false, meaning we have collected the full key "name"
            and can now look up its value in the map.*/

            else if(readingkey) // If we are reading inside parentheses, we are building key char by char
            {key.append(c);}

            else
            {ans.append(c);}
        }

        return ans.toString();
    }
}